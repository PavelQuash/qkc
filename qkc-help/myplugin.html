<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>qshKeyCommander1 - Создание своего плагина</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<META NAME="Author" CONTENT="<Quash!> aka Павел Х">
<META NAME="Keywords" CONTENT="quash, qshKeyCommander">
<STYLE>
A:LINK   {COLOR:#0000FF; TEXT-DECORATION:NONE;}
A:VISITED{COLOR:#0000FF; TEXT-DECORATION:NONE;}
A:HOVER  {COLOR:#FF0000; TEXT-DECORATION:UNDERLINE;}
</STYLE>
</HEAD>

<BODY>

<TABLE cellSpacing=0 cellPadding=0 width="80%" border=0 ALIGN=center>
<TR><TD STYLE="text-align:justify"><FONT SIZE=2 FACE="verdana">

<H4>Создание своего плагина</H4>

Создание плагина для qshKeyCommander не простое, а очень простое - главное понять смысл! Интерфейс уже продуман, вам остаётся только реализовать функции, ну и немного поработать над диалогом настройки. ;) ДЕРЗАЙТЕ!<br>

<OL>
	<LI><A HREF="#intro"  >Вступление</A>
	<LI><A HREF="#how"    >Взаимодействие программы и плагина</A>
	<LI><A HREF="#example">Пример простейшего плагина</A>
	<LI><A HREF="#links"  >Ссылки на полезные ресурсы</A>
</OL>

<A name="intro"><H4>Вступление</H4></A>
Вообще плагин состоит из списка, каждый элемент которого описывает соответствующую ему по номеру функцию (описание должно быть не более 200 символов), а также из пяти функций, предназначенных для следующих целей:
<UL>
	<LI>GetModuleData - возвращение программе информации о плагине;
	<LI>[Init] - инициализация, начало отслеживания программой сообщений;
	<LI>[Quit] - деинициализация, конец отслеживания сообщений;
	<LI>[Config] - конфигурация плагина, реализуется на усмотрение разработчика;
	<LI>[Command] - функция выполнения команды под номером cmdid;
</UL>
Квадратные скобки означают, что функция необязательна, то есть просто напросто может отсутствовать. Кроме того имена функциям даны по умолчанию, их можно менять по своему усмотрению, кроме первой - она должна быть всегда, и именно "GetModuleData". 
<br><br>
Вот и всё, что необходимо знать, ориентируясь по нижеприведённому исходнику! Но всё же существуют ещё некоторые подробности, которые необходимо знать для достижения максимального эффекта, поэтому не поленитесь прочитать весь документ :).
<br><br>
Ниже приведён пример простейшего плагина для qshKeyCommander, написанный на языке Microsoft Visual C++ 6.0, который можно, "не отходя от кассы", просто скомпилировать и использовать, а затем уже развивать мысль дальше. Перевод на другие языки программирования не должен доставить особого беспокойства, так как упор делался на простоту разработки плагинов.
<br><br>
Для уменьшения размера плагина нужно включить игнорирование стандартных библиотек, зайти в настройки Project->Settings (Alt+F7) и поставить оптимизацию на Minimize Size (хоть как-то уменьшает), отключить опцию nowin98 - обратитесь к статьям, на которые даны ссылки в соответствующем разделе. При этом придётся писать на чистом WinAPI...

<A name="how"><H4>Взаимодействие программы и плагина</H4></A>
 Для начала будет рассказан принцип взаимодействия плагина и программы, а затем - в каких случаях запускаются функции и что они должны выполнять.<br>
 <br>
 Расширение файла плагина должно быть "qkc" (всё выставляется в настройках MS VC++).<br>
 <br>
 Программа всегда ищет плагины в каталоге "<папка программы>\Plugins", а если он не существует, то просто в "<папка программы>".<br>
 <br>
 В начале работы модуля выполняется заполнение списка, который содержит описания для каждой функции, а также передаётся информация о количестве элементов списка. Заполнение может быть произведено как при подключении модуля (см. исходник), так и при вызове GetModuleData перед передачей данных - это не существенно, так как главное, чтобы при передаче адреса списка, он был уже заполнен.
 <UL>
 	<LI>GetModuleData - предназначена для передачи адреса в памяти частично заполненной структуры (см. исходник) - модулю, который должен заполнить все оставшиеся поля и при необходимости воспользоваться уже заполненными; функция вызывается во время подключения плагина (при загрузке, при подключении), а при завершении передачи qshKeyCommander уже знает, что "взять" с данного плагина; также после добавления плагина в память программы, подгружаются данные, хранящиеся в файле инициализации, которые содержат информацию о клавишах, кнопках ПДУ и так далее; эти данные плагину не доступны; имя функции меняться не может;
 	<LI>[Init] - функция вызывается, когда отслеживание сообщений уже установлено и плагину необходимо сделать какие-либо действия, например, создать окно для отслеживания горячей клавиши или запустить таймер; функция вызывается при загрузке (когда программа включает отслеживание сообщений), а также при выходе из диалога настройки; если в модуле функция не используется, то для правильной работы необходимо передать вместо её адреса NULL;
	<LI>[Quit] - функция вызывается в противоположных Init случаях, то есть когда отслеживание сообщений необходимо убрать (конец работы программы, вывод диалога настроек) - производится вызов функции (например, для уничтожения окна или таймера), а затем убирается отслеживание; если в модуле функция не используется, то для правильной работы необходимо передать вместо её адреса NULL;
	<LI>[Config] - функция обычно вызывается из диалога настройки программы, здесь можно создать диалог конфигурации для изменения настроек, характерных текущему плагину; функция может быть выполнена и самим плагином, как в случае с Winamp.qkc (если не найден исполняемый файл программы); перед выполнением данной фукции прячутся все программные окна; если в модуле функция не используется, то для правильной работы необходимо передать вместо её адреса NULL;
	<LI>[Command] - вызов функции осуществляется в любое время при реакции программы на поступающие сообщения, которые отслеживаются программой; функции передаётся параметр, определяющий идентификатор команды, которую нужно выполнить; если в модуле функция не используется, то для правильной работы необходимо передать вместо её адреса NULL;
 </UL>
 Для передачи данных о плагине вам потребуется структура, описанная в файле <A HREF="qkc_plugin.zip">qkc_plugin.zip (586 байт)</A>, который подключается к проекту (см. по исходному тексту). Структура имеет следующий вид:
 <PRE><FONT SIZE=2 FACE="courier new" COLOR=#990033>
 struct stPluginData
 {                             // КОММЕНТАРИЙ              (ЗАПОЛНЕНИЕ)
  char FileName[MAX_PATH];     // Имя файла модуля         (программой)
  HMODULE hDll;                // Хэндл модуля             (программой)
  char *Caption;               // Заголовок dll, версия    (модулем)
  void (*Init)   (void);       // Инициализация            (модулем)
  void (*Quit)   (void);       // Завершение работы        (модулем)
  void (*Config) (void);       // Настройка модуля         (модулем)
  void (*Command)(int cmdid);  // Выполнение команды       (модулем)
  char (*CommandsList) [200];  // Список команд модуля     (модулем)
  int  *CommandsCount;         // Количество команд        (модулем)
 };
 </FONT></PRE>
 Здесь:<br>
 - FileName уже заполнена именем файла модуля;<br>
 - в hDll уже хранится хэндл модуля;<br>
 - для Caption должна быть уже выделена память; передаётся адрес строки, содержащей информацию о версии модуля и его авторе;<br>
 - [Init, Quit, Config, Command] - содержатся адреса функций;<br>
 - CommandsList - указатель на список в памяти, описывающий команды;<br>
 - CommandsCount - указатель в памяти, содержащий число элементов в вышеприведённом списке.<br>

<A name="example"><H4>Пример простейшего плагина</H4></A>
<PRE><FONT SIZE=2 FACE="courier new" COLOR=#990033>
#include "windows.h"
#include "qkc_plugin.h"

#define CMDCOUNT 4
int  CmdCount = CMDCOUNT;    // Количество команд, используемое в плагине
char CmdList[CMDCOUNT][200]; // Список команд

// Подключение/отключение модуля
BOOL APIENTRY 
DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
 switch (ul_reason_for_call)
  {
   case DLL_PROCESS_ATTACH:
    // Заполнение списка
    lstrcpy(CmdList[0],"Command 1");
    lstrcpy(CmdList[1],"Command 2");
    lstrcpy(CmdList[2],"Command 3");
    lstrcpy(CmdList[3],"Command 4");
    break;

   case DLL_PROCESS_DETACH:
    break;
  }
 return true;
}

// Функция инициализации
void Init(void)
{ MessageBox(0,"MyPlugin Init","Info:",0); }

// Функция деинициализации
void Quit(void)
{ MessageBox(0,"MyPlugin Quit","Info:",0); }

// Конфигурация плагина
void Config(void)
{ MessageBox(0,"MyPlugin Config","Info:",0); }

// Запрос на выполнение команды под номером cmdid
void Command(int cmdid)
{
 switch (cmdid)
  {
   case 0:
    MessageBox(0,"MyPlugin Command 1","Действие",0);
	break;
   case 1:
    MessageBox(0,"MyPlugin Command 2","Действие",0);
    break;
   case 2:
    MessageBox(0,"MyPlugin Command 3","Действие",0);
	break;
   case 3:
    MessageBox(0,"MyPlugin Command 4","Действие",0);
	break;
   // Реакция на постороннее сообщение (на всякий случай)
   default:
    break;
  }
}



#ifdef __cplusplus
extern "C"
{
#endif

// Функция на экспорт, вызываемая плагином по умолчанию
__declspec (dllexport) void GetModuleData(struct stPluginData *PluginData)
{
 // Заполнение заголовка
 PluginData->Caption = "MyPlugin v1.666 =)\n\nCreated by Vasya Pupkin, 2004";

 // Передача адресов функций qshKeyCommander'у
 PluginData->Init          = Init;
 PluginData->Quit          = Quit;
 PluginData->Config        = Config;
 PluginData->Command       = Command;
 
 // Передача адресов списка и количества его элементов в памяти
 PluginData->CommandsCount = &CmdCount;
 PluginData->CommandsList  = CmdList;
}

#ifdef __cplusplus
}
#endif
</PRE></FONT>

<A name="links"><H4>Ссылки на полезные ресурсы</H4></A>
Интересные статьи, и какой эффект!!! При прочтении данного материала можно "въехать" в то, как сделать приложение, например, не 24 килобайта (по умолчанию) а всего-навсего 3-5 килобайт. Причём не просто вставляя текст директив компилятора, а осознавая, что делает каждая команда!
<br><br>
www.uinc.ru:<br>
<A HREF="http://www.uinc.ru/articles/28/index.shtml">Написание экстра-маленьких Win32 приложений на С++</A>
<br>
www.rsdn.ru:<br>
<A HREF="http://www.rsdn.ru/article/?cpp/crt.xml">Анатомия C Run-Time, или Как сделать программу немного меньшего размера</A>

</FONT></TD></TR>
</TABLE>

</BODY>
</HTML>